        -:    0:Source:Voting.cpp
        -:    0:Graph:TestVoting-Voting.gcno
        -:    0:Data:TestVoting-Voting.gcda
        -:    0:Runs:1
        -:    1:// -----------
        -:    2:// Voting.cpp
        -:    3:// -----------
        -:    4:
        -:    5:// --------
        -:    6:// includes
        -:    7:// --------
        -:    8:
        -:    9:using namespace std;
        -:   10:
        -:   11:#include "Voting.hpp"
        -:   12:
        -:   13:// clears all ballots for all candidates at the start
function _Z12clear_ballotR8Election called 2 returned 100% blocks executed 100%
        2:   14:void clear_ballot (Election& curr) {
       10:   15:    for (int i = 0;  i < curr.candidates.size(); i++) {
call    0 returned 100%
branch  1 taken 80%
branch  2 taken 20% (fallthrough)
        8:   16:        curr.candidates[i].candidate_ballots.clear();
call    0 returned 100%
call    1 returned 100%
        -:   17:    }
        2:   18:    return;
        -:   19:}
        -:   20:
        -:   21:// tallies up the votes for each candidate
function _Z11count_votesR8Election called 2 returned 100% blocks executed 100%
        2:   22:void count_votes(Election& curr) {
        -:   23:    Candidate* current;
        -:   24:    Ballot* temp;
        -:   25:
       14:   26:    for (int i = 0; i < curr.ballots.size(); i++) {
call    0 returned 100%
branch  1 taken 86%
branch  2 taken 14% (fallthrough)
       12:   27:        temp = &curr.ballots[i];
call    0 returned 100%
       12:   28:        current = &curr.candidates[temp->preferences[temp->current_index] - 1];
call    0 returned 100%
call    1 returned 100%
       12:   29:        current->candidate_ballots.push_back(temp);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   30:    }
        4:   31:    return;
        -:   32:}
        -:   33:
        -:   34:// check for winner and also getting min and max number of votes
function _Z12check_winnerR8ElectionPi called 2 returned 100% blocks executed 81%
        2:   35:bool check_winner (Election& curr, int* max_min) {
        -:   36:    Candidate* current;
        -:   37:
        -:   38:    // number of votes to be at > 50%
        2:   39:    const int num_votes_to_win = curr.ballots.size() / 2 + 1;
call    0 returned 100%
        -:   40:
       10:   41:    for (int i = 0;  i < curr.candidates.size(); i++) {
call    0 returned 100%
branch  1 taken 80%
branch  2 taken 20% (fallthrough)
        8:   42:        current = &curr.candidates[i];
call    0 returned 100%
        8:   43:        int size = current->candidate_ballots.size();
call    0 returned 100%
       8*:   44:        assert (size <= curr.ballots.size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   45:
        -:   46:        // found winner
        8:   47:        if (size >= num_votes_to_win) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   48:            cout << current->name << endl;
call    0 never executed
call    1 never executed
    #####:   49:            return true;
        -:   50:
        -:   51:        } else {
        -:   52:            // get max and min
        8:   53:            if (size > max_min[0]) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        2:   54:                max_min[0] = size;
        -:   55:            }
        8:   56:            if (size < max_min[1] && size != 0) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
branch  2 taken 60% (fallthrough)
branch  3 taken 40%
        3:   57:                max_min[1] = size;
        -:   58:            }
        -:   59:        }
        -:   60:    }
        -:   61:
        2:   62:    return false;
        -:   63:}
        -:   64:
        -:   65:
        -:   66:// populate the losers list with the losers
function _Z20populate_losers_listRSt6vectorIP9CandidateSaIS1_EER8Electionii called 2 returned 100% blocks executed 100%
        2:   67:int populate_losers_list(vector<Candidate*>& losers, Election& curr, int min,
        -:   68:                         int max) {
       10:   69:    for (int i = 0; i < curr.candidates.size(); i++) {
call    0 returned 100%
branch  1 taken 80%
branch  2 taken 20% (fallthrough)
        -:   70:
        -:   71:        // if min == max, means its a draw, don't want to add those to losers
        4:   72:        if (min != max && curr.candidates[i].candidate_ballots.size() == min
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
       12:   73:                || curr.candidates[i].candidate_ballots.size() == 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
branch  6 taken 50% (fallthrough)
branch  7 taken 50%
        4:   74:            losers.push_back(&curr.candidates[i]);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        4:   75:            curr.candidates[i].out = true;
call    0 returned 100%
        -:   76:        }
        -:   77:    }
        2:   78:    return losers.size();
call    0 returned 100%
        -:   79:}
        -:   80:
        -:   81:// return true if tie and print candidate names, return false otherwise
function _Z9check_tieR8Electionii called 2 returned 100% blocks executed 100%
        2:   82:bool check_tie( Election& curr, int min, int max) {
        2:   83:    if (max == min) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:   84:        for (int i = 0; i < curr.candidates.size(); i++) {
call    0 returned 100%
branch  1 taken 80%
branch  2 taken 20% (fallthrough)
        4:   85:            if (!curr.candidates[i].out) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        2:   86:                cout << curr.candidates[i].name << endl;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   87:            }
        -:   88:        }
        1:   89:        return true;
        -:   90:    }
        1:   91:    return false;
        -:   92:}
        -:   93:
        -:   94:// update the current index, increment if voted for a loser to a contender
function _Z19shift_current_indexRSt6vectorIP9CandidateSaIS1_EER8Election called 1 returned 100% blocks executed 100%
        1:   95:void shift_current_index(vector<Candidate*>& losers, Election& curr) {
        3:   96:    for (int i = 0; i < losers.size(); i++) {
call    0 returned 100%
branch  1 taken 67%
branch  2 taken 33% (fallthrough)
        2:   97:        Candidate* current = losers[i];
call    0 returned 100%
        4:   98:        for (int i = 0; i < current->candidate_ballots.size(); i++) {
call    0 returned 100%
branch  1 taken 50%
branch  2 taken 50% (fallthrough)
        2:   99:            Ballot* temp = current->candidate_ballots[i];
call    0 returned 100%
        -:  100:
        -:  101:            // do in a while loop to ensure that current_index points to an
        -:  102:            // eligible candidate
        5:  103:            while (curr.candidates[temp->preferences[temp->current_index] - 1].out) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 60%
branch  3 taken 40% (fallthrough)
        3:  104:                temp->current_index++;
        -:  105:            }
        -:  106:        }
        -:  107:    }
        1:  108:}
        -:  109:
        -:  110:
